// =============================================================================
// CODING CHALLENGE & GAMIFICATION SYSTEM
// =============================================================================
// This file contains all models related to coding challenges, submissions,
// leaderboards, badges, and gamification features for the platform.

// =============================================================================
// CHALLENGE ORGANIZATION MODELS
// =============================================================================

/// Represents a container for a month's worth of coding challenges.
/// Provides thematic organization and temporal grouping of challenges.
/// 
/// Monthly Challenge Features:
/// - Seasonal or thematic challenge collections
/// - Time-bound challenge sets with activation control
/// - Unique month/year combinations prevent duplicates
/// - Centralized management of challenge availability
/// 
/// Business Logic:
/// - Only one monthly challenge set per month/year combination
/// - isActive controls whether challenges accept submissions
/// - Theme provides optional thematic context for the month
/// - All challenges within a month share the same activation status
model MonthlyChallenge {
  id       String  @id @default(ulid())
  /// The title of the monthly challenge set (e.g., "June 2024 Code Challenge").
  title    String
  /// The month of the challenge (1-12).
  month    Int
  /// The year of the challenge.
  year     Int
  /// An optional theme for the month's challenges.
  theme    String?
  /// Whether this set of challenges is currently active and accepting submissions.
  isActive Boolean @default(false)

  challenges Challenge[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([month, year])
}

// =============================================================================
// CORE CHALLENGE MODELS
// =============================================================================

/// Represents an individual coding challenge.
/// Contains problem description, test cases, and solution templates.
/// 
/// Challenge Features:
/// - Multi-language support with boilerplate templates
/// - Difficulty-based point system for scoring
/// - Comprehensive test case validation
/// - Progressive hint system for learning
/// - Detailed solution explanations
/// - SEO-friendly slug for URL routing
/// 
/// Content Structure:
/// - description: Markdown-formatted problem statement
/// - template: JSON object with language-specific boilerplate code
/// - hints: JSON array of progressive hints for users
/// - solution: Detailed explanation of optimal approach
/// 
/// Scoring System:
/// - Points awarded based on difficulty level
/// - Additional points for optimization and style
/// - Bonus points for first submissions or creative solutions
model Challenge {
  id          String              @id @default(ulid())
  /// The title of the challenge.
  title       String
  /// A unique, URL-friendly identifier for the challenge.
  slug        String              @unique
  /// A detailed description of the challenge, in Markdown format.
  description String
  /// The difficulty level of the challenge.
  difficulty  ChallengeDifficulty @default(MEDIUM)
  /// The number of points awarded for successfully completing the challenge.
  points      Int                 @default(100)
  /// A JSON object containing boilerplate code for different languages.
  template    Json?
  /// A JSON array of hints to help the user.
  hints       Json?
  /// A detailed explanation of the optimal solution.
  solution    String?

  monthlyChallengeId String
  monthlyChallenge   MonthlyChallenge @relation(fields: [monthlyChallengeId], references: [id], onDelete: Cascade)

  submissions    ChallengeSubmission[]
  testCases      ChallengeTestCase[]
  userChallenges UserChallenge[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([monthlyChallengeId])
}

/// The difficulty level of a challenge.
/// Determines point values, complexity expectations, and user targeting.
enum ChallengeDifficulty {
  /// Beginner-friendly challenges focusing on basic concepts
  EASY
  /// Intermediate challenges requiring algorithmic thinking
  MEDIUM
  /// Advanced challenges with complex algorithms and optimizations
  HARD
}

// =============================================================================
// CHALLENGE TESTING SYSTEM
// =============================================================================

/// Represents a test case for a challenge, used to validate user submissions.
/// Supports both visible examples and hidden validation cases.
/// 
/// Test Case Features:
/// - Public example cases for user understanding
/// - Hidden test cases for comprehensive validation
/// - Edge case coverage for robust testing
/// - Performance testing with large inputs
/// - Security validation for malicious code prevention
/// 
/// Test Case Types:
/// - Example cases: Shown in problem description
/// - Basic cases: Standard validation scenarios
/// - Edge cases: Boundary conditions and special inputs
/// - Performance cases: Large inputs for optimization testing
/// - Hidden cases: Final validation not visible to users
model ChallengeTestCase {
  id             String  @id @default(ulid())
  /// The input data for the test case.
  input          String
  /// The expected output for the given input.
  expectedOutput String
  /// Whether this test case is hidden from the user during testing.
  isHidden       Boolean @default(false)
  /// Whether this is an example test case shown in the challenge description.
  isExample      Boolean @default(false)

  challengeId String
  challenge   Challenge @relation(fields: [challengeId], references: [id], onDelete: Cascade)

  @@index([challengeId])
}

// =============================================================================
// SUBMISSION & EXECUTION MODELS
// =============================================================================

/// Represents a user's attempt to solve a challenge.
/// Tracks code submissions, execution results, and scoring metrics.
/// 
/// Submission Features:
/// - Multi-language code execution support
/// - Comprehensive result tracking and debugging
/// - Performance metrics (time/memory usage)
/// - Detailed error reporting and feedback
/// - Anti-cheat measures and code similarity detection
/// - Badge eligibility tracking
/// 
/// Execution Pipeline:
/// 1. Code submission and language validation
/// 2. Security scanning and sandboxed execution
/// 3. Test case validation and scoring
/// 4. Performance metrics collection
/// 5. Badge evaluation and leaderboard updates
/// 
/// Result Structure:
/// - result JSON contains: stdout, stderr, test results, debug info
/// - Execution metrics for performance analysis
/// - Detailed feedback for learning purposes
model ChallengeSubmission {
  id            String           @id @default(ulid())
  /// The code submitted by the user.
  code          String
  /// The programming language of the submitted code.
  language      String
  /// The result of the submission (e.g., PENDING, ACCEPTED, WRONG_ANSWER).
  status        SubmissionStatus @default(PENDING)
  /// The score awarded for this submission.
  score         Int              @default(0)
  /// The execution time of the submission in milliseconds.
  executionTime Int?
  /// The memory used by the submission in kilobytes.
  memoryUsage   Int?
  /// A JSON object containing detailed results, such as stdout, stderr, and test case outcomes.
  result        Json?

  userId String
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  challengeId String
  challenge   Challenge @relation(fields: [challengeId], references: [id], onDelete: Cascade)

  submittedAt        DateTime            @default(now())
  userChallengeBadge UserChallengeBadge?

  @@index([userId])
  @@index([challengeId])
  @@index([status])
}

/// The status of a code submission.
/// Represents the outcome of code execution and validation.
enum SubmissionStatus {
  /// Submission received, queued for processing
  PENDING
  /// Code is currently being executed
  RUNNING
  /// All tests passed successfully - optimal outcome
  ACCEPTED
  /// Code executed but produced incorrect output
  WRONG_ANSWER
  /// Code execution exceeded allowed time limit
  TIME_LIMIT_EXCEEDED
  /// Code execution used more memory than allowed
  MEMORY_LIMIT_EXCEEDED
  /// Code crashed or threw an exception during execution
  RUNTIME_ERROR
  /// Code failed to compile or has syntax errors
  COMPILE_ERROR
}

// =============================================================================
// USER PROGRESS TRACKING
// =============================================================================

/// Represents a user's state and progress for a specific challenge.
/// Tracks learning journey, code iterations, and completion status.
/// 
/// Progress Features:
/// - Persistent code saving across sessions
/// - Language preference tracking
/// - Solution viewing restrictions and tracking
/// - Learning analytics and engagement metrics
/// - Completion timestamps for achievement tracking
/// 
/// Learning Analytics:
/// - Time to completion tracking
/// - Code iteration patterns
/// - Hint usage analysis
/// - Solution viewing behavior
/// - Language preference trends
/// 
/// Business Logic:
/// - One progress record per user per challenge
/// - Code autosave prevents work loss
/// - Solution viewing affects scoring/badges
/// - Completion unlocks advanced challenges
model UserChallenge {
  id               String              @id @default(ulid())
  /// The user's current status for this challenge (e.g., NOT_STARTED, IN_PROGRESS).
  status           UserChallengeStatus @default(NOT_STARTED)
  /// The timestamp when the user first started the challenge.
  startedAt        DateTime?
  /// The timestamp when the user successfully completed the challenge.
  completedAt      DateTime?
  /// The user's last saved code for this challenge.
  currentCode      String?
  /// The user's last selected language for this challenge.
  currentLanguage  String?
  /// The timestamp when the user viewed the solution.
  viewedSolutionAt DateTime?

  userId      String
  user        User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  challengeId String
  challenge   Challenge @relation(fields: [challengeId], references: [id], onDelete: Cascade)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([userId, challengeId])
  @@index([userId])
  @@index([challengeId])
}

/// The user's progress status on a specific challenge.
/// Represents the learning journey through challenge completion.
enum UserChallengeStatus {
  /// Challenge has not been attempted yet
  NOT_STARTED
  /// User has started working on the challenge
  IN_PROGRESS
  /// Challenge has been successfully completed
  COMPLETED
}

// =============================================================================
// GAMIFICATION & ACHIEVEMENT SYSTEM
// =============================================================================

/// Represents an unlockable badge that can be earned by users.
/// Provides recognition and motivation through achievement systems.
/// 
/// Badge Features:
/// - Flexible criteria system using JSON configuration
/// - Visual recognition with custom images
/// - Tiered achievement levels (bronze, silver, gold)
/// - Special event and milestone badges
/// - Social sharing and profile display
/// 
/// Badge Categories:
/// - Completion badges: For finishing challenges/streaks
/// - Performance badges: For optimization and speed
/// - Learning badges: For consistent practice
/// - Community badges: For helping others
/// - Special badges: For events and milestones
/// 
/// Criteria Examples:
/// - {"challenges_completed": 10, "difficulty": "EASY"}
/// - {"streak_days": 7, "consecutive": true}
/// - {"languages_used": 3, "timeframe": "month"}
/// - {"rank": 1, "leaderboard": "monthly"}
model Badge {
  id          String @id @default(ulid())
  /// The name of the badge.
  name        String @unique
  /// A description of the badge and how to earn it.
  description String
  /// The badge's image.
  image       Image?
  /// A JSON object defining the criteria for earning the badge (e.g., points, challenges completed).
  criteria    Json

  users UserChallengeBadge[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

/// Represents an instance of a badge that has been awarded to a user.
/// Tracks when achievements were earned and links to triggering submissions.
/// 
/// Badge Award Features:
/// - Timestamped achievement tracking
/// - Optional link to triggering submission
/// - Unique awards prevent duplicates
/// - Achievement analytics and insights
/// - Social recognition and sharing
/// 
/// Business Logic:
/// - One badge award per user per badge type
/// - Awards are permanent and cannot be revoked
/// - Submission link provides achievement context
/// - Awards contribute to user reputation and ranking
model UserChallengeBadge {
  id       String   @id @default(ulid())
  /// The timestamp when the badge was earned.
  earnedAt DateTime @default(now())

  userId String
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  badgeId String
  badge   Badge  @relation(fields: [badgeId], references: [id], onDelete: Cascade)

  // Optionally link to the submission that earned the badge
  submissionId String?              @unique
  submission   ChallengeSubmission? @relation(fields: [submissionId], references: [id], onDelete: SetNull)

  @@unique([userId, badgeId])
  @@index([userId])
  @@index([badgeId])
}

// =============================================================================
// LEADERBOARD & RANKING SYSTEM
// =============================================================================

/// Represents a leaderboard for ranking users.
/// Supports multiple ranking contexts and time periods.
/// 
/// Leaderboard Features:
/// - Global and time-based ranking systems
/// - Language-specific competitions
/// - Seasonal and monthly competitions
/// - Real-time score updates
/// - Historical ranking preservation
/// 
/// Leaderboard Types:
/// - Global: All-time user rankings
/// - Monthly: Month-specific competitions
/// - Language: Programming language specialization
/// - Seasonal: Special event rankings
/// - Team: Organization-based competitions
/// 
/// Ranking Algorithm:
/// - Primary: Total points from challenge completions
/// - Secondary: Speed of completion (tiebreaker)
/// - Tertiary: Code quality and optimization
/// - Bonus: Consistency and streak multipliers
model Leaderboard {
  id       String           @id @default(ulid())
  /// The scope of the leaderboard (e.g., GLOBAL, MONTHLY).
  scope    LeaderboardScope @default(GLOBAL)
  /// The programming language for language-specific leaderboards.
  language String?
  /// The month for a monthly leaderboard.
  month    Int?
  /// The year for a monthly leaderboard.
  year     Int?

  entries LeaderboardEntry[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([scope, language, month, year])
}

/// The scope of a leaderboard.
/// Defines the temporal and contextual boundaries for rankings.
enum LeaderboardScope {
  /// All-time rankings across all users and challenges
  GLOBAL
  /// Time-limited monthly competition rankings
  MONTHLY
}

/// Represents a user's entry on a leaderboard.
/// Tracks individual performance within specific ranking contexts.
/// 
/// Leaderboard Entry Features:
/// - Real-time rank calculation and updates
/// - Score aggregation from multiple sources
/// - Historical rank tracking for trends
/// - Tie-breaking using secondary metrics
/// - Achievement milestone notifications
/// 
/// Ranking Factors:
/// - Challenge completion points
/// - Submission speed and efficiency
/// - Code quality metrics
/// - Consistency bonuses
/// - Community contribution scores
/// 
/// Business Logic:
/// - One entry per user per leaderboard
/// - Ranks are recalculated on score changes
/// - Entries are immutable for historical accuracy
/// - Scores reflect cumulative achievements
model LeaderboardEntry {
  id    String @id @default(ulid())
  /// The user's rank on the leaderboard.
  rank  Int
  /// The user's score on the leaderboard.
  score Int

  userId String
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  leaderboardId String
  leaderboard   Leaderboard @relation(fields: [leaderboardId], references: [id], onDelete: Cascade)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([leaderboardId, userId])
  @@index([leaderboardId])
  @@index([userId])
  @@index([score])
}
